<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GD Room</title>
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <header class="topbar">
    <a href="/">← Home</a>
    <div id="info"></div>
  </header>

  <main class="room">
    <section class="controls">
      <div id="roleBadge"></div>
      <button id="toggleVideo">Toggle Video</button>
      <button id="toggleAudio">Toggle Mic</button>
      <button id="startRecord" style="display:none">Start Recording (Manager)</button>
      <button id="stopRecord" style="display:none">Stop & Upload</button>
      <div id="shareLink" style="margin-top:10px"></div>
    </section>

    <section id="videos" class="videos"></section>
  </main>

  <script src="/socket.io/socket.io.js"></script>
  <script src="/main.js"></script>
  <script>
    (async function(){
      const params = new URLSearchParams(location.search);
      const room = params.get('room') || 'ROOM';
      const mode = params.get('mode') || 'practice';
      const role = params.get('role') || 'participant';
      const name = params.get('name') || role;
      document.getElementById('info').innerText = `Room: ${room} · ${mode}`;
      document.getElementById('roleBadge').innerText = `Role: ${role}`;

      const socket = io();
      const localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      const videos = document.getElementById('videos');

      function addVideoEl(id, stream, label){
        let el = document.querySelector(`[data-id="${id}"]`);
        if(!el){
          el = document.createElement('div');
          el.className = 'tile';
          el.setAttribute('data-id', id);
          const v = document.createElement('video');
          v.autoplay = true; v.playsInline = true; v.muted = false; v.srcObject = stream;
          const caption = document.createElement('div'); caption.className='caption'; caption.innerText = label || id;
          el.appendChild(v); el.appendChild(caption);
          videos.appendChild(el);
        } else {
          const v = el.querySelector('video'); v.srcObject = stream;
        }
      }

      // show local
      addVideoEl('me', localStream, `${name} (you)`);

      // Signaling + mesh peers
      const pcs = {};
      const localTracks = localStream.getTracks();

      socket.emit('join-room', { room, name, role });

      socket.on('joined', async ({ id, peers }) => {
        // create offer to existing peers
        for (const peerId of peers) await createOffer(peerId);
      });

      socket.on('peer-joined', async ({ id: peerId, name: peerName }) => {
        // when a new peer joins after us, create offer to them
        await createOffer(peerId);
      });

      socket.on('peer-left', ({ id }) => {
        if (pcs[id]) { pcs[id].close(); delete pcs[id]; const el = document.querySelector(`[data-id="${id}"]`); if(el) el.remove(); }
      });

      socket.on('signal', async ({ from, data }) => {
        let pc = pcs[from];
        if (data.sdp) {
          if (data.sdp.type === 'offer') {
            pc = new RTCPeerConnection();
            localTracks.forEach(t => pc.addTrack(t, localStream));
            pc.onicecandidate = e => { if (e.candidate) socket.emit('signal', { to: from, data: { ice: e.candidate } }); };
            pc.ontrack = e => { addVideoEl(from, e.streams[0], `Peer ${from}`); if (isManager) attachToManagerRecording(e.streams[0]); };
            await pc.setRemoteDescription(data.sdp);
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            socket.emit('signal', { to: from, data: { sdp: pc.localDescription } });
            pcs[from] = pc;
          } else if (data.sdp.type === 'answer') {
            if (pc) await pc.setRemoteDescription(data.sdp);
          }
        } else if (data.ice) {
          if (pc) await pc.addIceCandidate(data.ice).catch(()=>{});
        }
      });

      async function createOffer(peerId){
        const pc = new RTCPeerConnection();
        localTracks.forEach(t => pc.addTrack(t, localStream));
        pc.onicecandidate = e => { if (e.candidate) socket.emit('signal', { to: peerId, data: { ice: e.candidate } }); };
        pc.ontrack = e => { addVideoEl(peerId, e.streams[0], `Peer ${peerId}`); if (isManager) attachToManagerRecording(e.streams[0]); };
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        socket.emit('signal', { to: peerId, data: { sdp: pc.localDescription } });
        pcs[peerId] = pc;
      }

      // Recording (manager)
      const isManager = role === 'manager';
      let recorder = null;
      const managerStream = new MediaStream();
      function attachToManagerRecording(s){
        s.getTracks().forEach(t => managerStream.addTrack(t));
      }
      // include local tracks
      localTracks.forEach(t => managerStream.addTrack(t));

      const startBtn = document.getElementById('startRecord');
      const stopBtn = document.getElementById('stopRecord');
      const shareEl = document.getElementById('shareLink');

      if (isManager) {
        startBtn.style.display = 'inline-block';
        stopBtn.style.display = 'inline-block';
      }

      startBtn?.addEventListener('click', () => {
        recorder = new MediaRecorder(managerStream);
        const chunks = [];
        recorder.ondataavailable = e => chunks.push(e.data);
        recorder.onstop = async () => {
          const blob = new Blob(chunks, { type: 'video/webm' });
          const fd = new FormData(); fd.append('recording', blob, `gd-${room}.webm`); fd.append('room', room);
          const res = await fetch('/upload', { method: 'POST', body: fd });
          const json = await res.json();
          const link = json.url;
          shareEl.innerHTML = `Recording uploaded: <a href="${link}" target="_blank">${link}</a>`;
          // After upload, open analysis page
          setTimeout(()=> location.href = `/analysis.html?recording=${encodeURIComponent(link)}&room=${encodeURIComponent(room)}` , 1000);
        };
        recorder.start();
        startBtn.disabled = true; stopBtn.disabled = false;
      });

      stopBtn?.addEventListener('click', () => {
        if (recorder && recorder.state !== 'inactive') recorder.stop();
        startBtn.disabled = false; stopBtn.disabled = true;
      });

      // toggles
      document.getElementById('toggleVideo').addEventListener('click', () => {
        localStream.getVideoTracks().forEach(t => t.enabled = !t.enabled);
      });
      document.getElementById('toggleAudio').addEventListener('click', () => {
        localStream.getAudioTracks().forEach(t => t.enabled = !t.enabled);
      });

    })();
  </script>
</body>
</html>
